""" In this program we will be predicting the type of digit in an image by using nueral networks
so we will be using tensorflow library in this program"""


import tensorflow
tensorflow.__version__

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from tensorflow.keras.utils import to_categorical

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, Flatten, Dense, Dropout, MaxPooling2D, BatchNormalization

from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau
from tensorflow.keras import regularizers, optimizers


import random   # Initialize the random number generator
random.seed(0)

import warnings   # Ignore the warnings

warnings.filterwarnings('ignore')  # suppress display of warnings

""" To display all dataframe rows and columns without those dots"""

pd.options.display.max_columns = None
pd.options.display.max_rows = None

pd.options.display.float_format = '{:.7f}'.format    # To set the limit to 3 decimals

train = pd.read_csv('train.csv')
train.head()
test = pd.read_csv('../input/digit-recognizer/test.csv')

"""This data set consists of pixel value of each images in a row"""

features = train.drop('label', axis=1)
y_train = train['label']

# Train images
X_ = np.array(features)
X_train = X_.reshape(X_.shape[0], 28, 28)

# Test images
X_test = np.array(test)

# Lets reshape the train and test sets into compatible shapes
X_train = X_train.reshape(X_train.shape[0], 28, 28, 1)
X_test = X_test.reshape(X_test.shape[0], 28, 28, 1)

X_train = X_train.astype('float32')
X_test = X_test.astype('float32')

X_train /= 255
X_test /= 255

# Convert the final label value into categorical value between 0 to 9
y_train = to_categorical(y_train, num_classes=10)

#Initialize a sequential model

model = Sequential()
model.add(Conv2D(filters=32, kernel_size=3, activation="relu", input_shape=(28, 28, 1)))
model.add(Conv2D(filters=32, kernel_size=3, activation="relu"))
model.add(Flatten())
model.add(Dense(128, activation="relu"))
model.add(Dense(10, activation="softmax"))

# Compile the model
model.compile(loss="categorical_crossentropy", metrics=["accuracy"], optimizer="adam")

# Fit the model
model.fit( x=X_train, y=y_train, batch_size=32, epochs=10, validation_split = 0.3)

#  Lets to the CNN + Pooling + Dropout

# Initialize the model
model = Sequential()

# Add a Convolutional Layer with 32 filters of size 3X3 and activation function as 'relu' 
model.add(Conv2D(filters=32, kernel_size=3, activation="relu", input_shape=(28, 28, 1)))

model.add(BatchNormalization())

# Add a Convolutional Layer with 32 filters of size 3X3 and activation function as 'relu' 
model.add(Conv2D(filters=32, kernel_size=3, activation="relu"))
model.add(BatchNormalization())

# Add a MaxPooling Layer of size 2X2 
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(BatchNormalization())

# Apply Dropout with 0.2 probability 
model.add(Dropout(rate=0.2))

# Flatten the layer
model.add(Flatten())

# Add Fully Connected Layer with 128 units and activation function as 'relu'
model.add(Dense(128, activation="relu"))
model.add(BatchNormalization())

#Add Fully Connected Layer with 10 units and activation function as 'softmax'
model.add(Dense(10, activation="softmax"))

# Optimizer
sgd = optimizers.SGD(lr=2e-2, decay=1e-6, momentum=0.9)
      
# Compile the model
model.compile(loss="categorical_crossentropy", metrics=["accuracy"], optimizer=sgd)

# Adding callbacks
es = EarlyStopping(monitor='val_loss', mode = 'min', patience=10, min_delta=1E-4, restore_best_weights=True)
rlrp = ReduceLROnPlateau(monitor='val_loss', factor=0.0001, patience=10, min_delta=1E-4)

callbacks = [es, rlrp]

# Fit the model
training_history = model.fit(x=X_train, y=y_train, batch_size=16, epochs=100, validation_split = 0.3, callbacks=[callbacks])

# Lets predict our test dataset on the model
preds = np.argmax(model.predict(X_test), axis=1)


""" Thus we have compiled the digit recognizer model"""













